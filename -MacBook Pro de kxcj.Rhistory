dat <- read.csv(filename)
dat
f <- dnorm
x <- seq(-4,4,length=100)
plot(x, f(x), type="l")  # x = x; f(x) = y; tipo de gráfica: línea.
x0 <- x[x>2]
y0 <- f(x0)
x0 <- c(min(x0),x0,max(x0))
y0 <- c(0,y0,0)
polygon(x0,y0,col="grey")
# ¿Cómo podemos medir el área bajo la curva?
# Calculando la integral de la función... es decir, con una suma infinita de
# barras pequeñas cuya solución para este ejemplo es de 2.27%.
# Podemos aproximarnos con una suma de barras no tan pequeñas de ancho 0.01:
width <- 0.01
x <- seq(2,4,width)
areaofbars <-  f(x)*width
sum(areaofbars)
# Calcular el promedio de cada grupo
library(dplyr)
control <- filter(dat,Diet=="chow") %>% select(Bodyweight) %>% unlist  # ¿Por qué es control?
treatment <- filter(dat,Diet=="hf") %>% select(Bodyweight) %>% unlist  # ¿Por qué es tratamiento?
print( mean(treatment) )
print( mean(control) )
obsdiff <- mean(treatment) - mean(control)   # DIFERENCIA DE PROMEDIOS/MEDIAS  ==> ¿A qué número tiende la diferencia cuándo las medias son iguales?
print(obsdiff)
# VARIABLES ALEATORIAS
# Imaginemos que tenemos TODOS los registros del peso de los ratones hembra del grupo
# de control: esto en estadística es la POBLACIÓN. En la práctica casi nunca tenemos acceso
# a la población.
population <- read.csv("femaleControlsPopulation.csv")
# INFERENCIA
# Fijar directorio de trabajo
setwd("~/Documents/OneDrive/R/Cursos/Intro_estadistica/BD")
library(readr)
femaleControlsPopulation <- read_csv("C:/Users/kxcj/OneDrive/Educacion/Cursos/Impartidos/Intro_estadistica/BD/femaleControlsPopulation.csv")
View(femaleControlsPopulation)
population <- femaleControlsPopulation
# usar unlist para convertirlo en un vector numérico
population <- unlist(population)
# Obtener tres muestras de tamaño 12 y estimar sus medias
control <- sample(population,12)
mean(control)
control <- sample(population,12)
mean(control)
control <- sample(population,12)
mean(control)
# 12 ratones de control
control <- sample(population,12)
# Otros 12 ratones de control que "actuarán" como si no lo fueran
treatment <- sample(population,12)
print(mean(treatment) - mean(control))
# Hagamos esto 10,000 veces
n <- 10000
null <- vector("numeric",n)
for (i in 1:n) {
control <- sample(population,12)
treatment <- sample(population,12)
null[i] <- mean(treatment) - mean(control)
}
null
# ¿Qué porcentaje de los 10,000 registros de NULL son más grandes que OBSDIFF?
mean(null >= obsdiff)
install.packages("UsingR")
library(UsingR)
data(father.son,package="UsingR")
x <- father.son$fheight
# Una manera de resumir estos números es simplificar la lista de todos ellos para que las
# vea el extraterrestre: 10 alturas de 1,078 seleccionadas al azar:
round(sample(x,10),1)
# FDAE/ECDF de las alturas:
smallest <- floor( min(x) )
largest <- ceiling( max(x) )
values <- seq(smallest, largest,len=300)
heightecdf <- ecdf(x)
plot(values, heightecdf(values), type="l",
xlab="a (Height in inches)",ylab="Pr(x <= a)")
hist(x)
# Podemos mejorar la gráfica
bins <- seq(smallest, largest)
hist(x,breaks=bins,xlab="Height (in inches)",main="Adult men heights")
n <- 100
#install.packages("rafalib")
library(rafalib)
nullplot(-5,5,1,30, xlab="Observed differences (grams)", ylab="Frequency")
totals <- vector("numeric",11)
for (i in 1:n) {
control <- sample(population,12)
treatment <- sample(population,12)
nulldiff <- mean(treatment) - mean(control)
j <- pmax(pmin(round(nulldiff)+6,11),1)
totals[j] <- totals[j]+1
text(j-6,totals[j],pch=15,round(nulldiff,1))
if(i < 15) Sys.sleep(1) ##You can add this line to see values appear slowly
}
abline(v=obsdiff, col="red", lwd=2)
# La figura anterior equivale a un histograma. A partir de un histograma del vector nulo que calculamos
# anteriormente, podemos ver que valores tan grandes como obsdiff son relativamente raros:
hist(null, freq=TRUE)
1 - pnorm(obsdiff,mean(null),sd(null))
# Hagamos esto 10,000 veces
n <- 10000
null <- vector("numeric",n)
for (i in 1:n) {
control <- sample(population,12)
treatment <- sample(population,12)
null[i] <- mean(treatment) - mean(control)
}
null
# ¿Qué porcentaje de los 10,000 registros de NULL son más grandes que OBSDIFF?
mean(null >= obsdiff)
install.packages("UsingR")
install.packages("UsingR")
# Una manera de resumir estos números es simplificar la lista de todos ellos para que las
# vea el extraterrestre: 10 alturas de 1,078 seleccionadas al azar:
round(sample(x,10),1)
# FDAE/ECDF de las alturas:
smallest <- floor( min(x) )
largest <- ceiling( max(x) )
values <- seq(smallest, largest,len=300)
heightecdf <- ecdf(x)
plot(values, heightecdf(values), type="l",
xlab="a (Height in inches)",ylab="Pr(x <= a)")
hist(x)
# Podemos mejorar la gráfica
bins <- seq(smallest, largest)
hist(x,breaks=bins,xlab="Height (in inches)",main="Adult men heights")
n <- 100
#install.packages("rafalib")
library(rafalib)
nullplot(-5,5,1,30, xlab="Observed differences (grams)", ylab="Frequency")
totals <- vector("numeric",11)
for (i in 1:n) {
control <- sample(population,12)
treatment <- sample(population,12)
nulldiff <- mean(treatment) - mean(control)
j <- pmax(pmin(round(nulldiff)+6,11),1)
totals[j] <- totals[j]+1
text(j-6,totals[j],pch=15,round(nulldiff,1))
if(i < 20) Sys.sleep(1) ##You can add this line to see values appear slowly
}
abline(v=obsdiff, col="red", lwd=2)
1 - pnorm(obsdiff,mean(null),sd(null))
url <- "https://raw.githubusercontent.com/genomicsclass/dagdata/master/inst/extdata/mice_pheno.csv"
filename <- "mice_pheno.csv"
# La figura anterior equivale a un histograma. A partir de un histograma del vector nulo que calculamos
# anteriormente, podemos ver que valores tan grandes como obsdiff son relativamente raros:
hist(null, freq=TRUE)
#install.packages("downloader")
library(downloader)
nullplot(-5,5,1,30, xlab="Observed differences (grams)", ylab="Frequency")
totals <- vector("numeric",11)
for (i in 1:n) {
control <- sample(population,12)
treatment <- sample(population,12)
nulldiff <- mean(treatment) - mean(control)
j <- pmax(pmin(round(nulldiff)+6,11),1)
totals[j] <- totals[j]+1
text(j-6,totals[j],pch=15,round(nulldiff,1))
if(i < 20) Sys.sleep(1) ##You can add this line to see values appear slowly
}
?seq
N <- seq(100, 10000, len=1000)
N
N <- seq(100, 10000, by=100)
N
N <- seq(100, 10000, by=100)
r = 0.05
p = 0.5
q = 1-p
Z = 1.96
n <- (N*(Z^2)*p*q) / (((r^2)*(N-1)) + ((Z^2)*p*q))
n
install.packages("ggpot")
install.packages("ggpot2")
install.packages("ggplot2")
library(ggplot2)
ggplot(data = n) +
geom_point(mapping = aes(x = cilindrada, y = autopista, color = clase))
ggplot() +
geom_line(mapping = aes(x = N, y = n, color = clase))
datos[,1] <-N
datos[1] <-N
?plot
plot(n, heightecdf(n), type="l",
xlab="a (Height in inches)",ylab="Pr(x <= a)")
plot(n, type="l",
xlab="a (Height in inches)",ylab="Pr(x <= a)")
datos <- rbind(N, n)
datos
datos <- as.data.frame(rbind(N, n))
datos
datos <- rbind(N, n)
library(ggplot2)
ggplot(datos) +
geom_line(mapping = aes(x = N, y = n, color = clase))
ggplot(datos) +
geom_line(mapping = aes(x = N, y = n))
datos <- rbind(N, n)
datos <- cbind(N, n)
datos
ggplot(datos) +
geom_line(mapping = aes(x = N, y = n))
datos <-as.data.frame(datos)
ggplot(datos) +
geom_line(mapping = aes(x = N, y = n))
N <- seq(100, 100000, by=10)
r = 0.05
p = 0.5
q = 1-p
Z = 1.96
n <- (N*(Z^2)*p*q) / (((r^2)*(N-1)) + ((Z^2)*p*q))
datos <- cbind(N, n)
datos <-as.data.frame(datos)
datos
ggplot(datos) +
geom_line(mapping = aes(x = N, y = n))
# Indexación
x <- 1:5
x
## Ayuda en R
?downloader
help("downloader")
?summary
## Tipo de datos
data(iris)
class(iris)
View(iris)
## Factores:
# en R los factores se utilizan para trabajar con variables categóricas
b <- iris$Species
class(b)
plot(iris$Species)
## R es interactivo
2 + 2
## Es una calculadora
# Multiplicación
4*5
# División
5/2
# División entera_
5%/%2
# Módulo resto
5%%2
# Potencia
5**3
5^3
# Potencia exponente real
5**2.3
5^2.3
# Raíz cuadrada
sqrt(9)
# Logaritmo
log(3)
# Número e (base de los logaritmos neperianos)
exp(1)
exp(1.0986122)
# Logaritmo
log(3)
exp(1.0986122)
# Valor absoluto
abs(-42.56)
ls
ls()
getwd()
## Infinito
onethird <- function(n) sum( 3/10^c(1:n))
1/3 - onethird(4)
1/3 - onethird(10)
1/3 - onethird(16)
# Integrales
f <- dnorm
x <- seq(-4,4,length=100)
plot(x, f(x), type="l")
x0 <- x[x>2]
y0 <- f(x0)
x0 <- c(min(x0),x0,max(x0))
y0 <- c(0,y0,0)
polygon(x0,y0,col="grey")
width <- 0.01
x2 <- seq(2,4,width)
areaofbars <-  f(x2)*width
sum( areaofbars )
url <- "https://raw.githubusercontent.com/cjjmdata/intro_estadistica_con_R/master/grupo_edad_altura.csv"
filename <- "grupo_edad_altura.csv"
download(url, destfile=filename)
dat <- read.csv(filename)
View(dat)
head(dat)
iris[,1]
iris
head(iris)
iris[,5]
iris[,5] == "versicolor"
iris[,iris[,5] == "versicolor"]
iris[,5] == "versicolor"
a <- iris[,5] == "versicolor"
iris[,a]
iris[a]
iris[,]
iris[,a]
iris[,5==a]
iris[,5=a]
iris[,5==a]
class(dat)
length(dat)
# Número de casos
length(iris)
# Número de casos
length(iris)
length(iris$Sepal.Length)
?length
url <- "https://raw.githubusercontent.com/cjjmdata/intro_estadistica_con_R/master/grupo_edad_altura.csv"
filename <- "grupo_edad_altura.csv"
download(url, destfile=filename)
dat <- read.csv(filename)
head(dat)
length(dat$genero)
class(dat$edad)
class(dat$altura)
class(4)
class(4.2)
class(4)
## Tipo de datos
data(iris)
class(iris)
View(iris)
class(4)
class(4.2)
class("Hola")
class(TRUE)
class(FALSE)
##Selección de columnas
# Opción 1
a <- iris$Sepal.Width
class(a)
# Opción 2: índices [filas,columnas]
a2 <- iris[,2]
a2
head(a2)
# Selección de filas y columnas
# Por rangos: [f_ini:f_fin, c_ini:c_fin]
a3 <- iris[,2:4] # Todas las filas
a3
a4 <- iris[10:20,2:4]
a4
knitr::opts_chunk$set(echo = FALSE)
summary(cars)
plot(pressure)
getwd
getwd()
knitr::opts_chunk$set(echo = FALSE)
plot(pressure)
bins <- seq(min(x), max(x), length.out = input$bins + 1)
knitr::opts_chunk$set(echo = FALSE)
ggplot(datos) +
geom_line(mapping = aes(x = N, y = n))
# Instalar paquetes
install.packages("ggplot2")
library(ggplot2)
# Tamaño de muestra
# Efecto del tamaño de la población N
N <- seq(100, 10000, by=10)
r = 0.05
p = 0.5
q = 1-p
Z = 1.96
n <- (N*(Z^2)*p*q) / (((r^2)*(N-1)) + ((Z^2)*p*q))
datos <- cbind(N, n)
datos <-as.data.frame(datos)
datos
ggplot(datos) +
geom_line(mapping = aes(x = N, y = n))
n
?seq
n
knitr::opts_chunk$set(echo = FALSE)
library(ggplot2)
r2 <- seq(0.00001, 0.15, length.out=1000)
N2 = 25000
p2 = 0.5
q2 = 1-p
Z2 = 1.96
n2 <- (N2*(Z2^2)*p2*q2) / (((r2^2)*(N2-1)) + ((Z2^2)*p2*q2))
datos <- cbind(N2, n2)
datos <-as.data.frame(datos)
n2
p <- seq(0.01, 1, length.out=1000)
N = 25000
q = 1-p
Z = 1.96
n <- ((Z^2)*N*p*q) / (((r^2)*(N-1)) + ((Z^2)*p*q))
set.seed(14)
altura <- rnorm(1000, 1.6896, 0.0786)
altura
mean(altura)
sd(altura)
ggplot(altura) +
geom_line(mapping = aes(x = altura))
plot(altura, heightecdf(altura), type="l",
xlab="a (Height in inches)",ylab="Pr(x <= a)")
heightecdf <- ecdf(x)
install.packages("UsingR")
max(altura)
min(altura)
# Rejilla de valores para x
x <- seq(1.40, 2, 1000)
# Rejilla de valores para x
x <- seq(1.40, 2, 0.01)
# Rejilla de valores para x
x <- seq(1.40, 2, 0.01)
set.seed(14)
plot(x, dnorm(x, mean = 1.6896, sd = 0.0786), type = "l",
ylim = c(0, 0.6), ylab = "", lwd = 2, col = "red")
plot(x, dnorm(x, mean = 1.6896, sd = 0.0786), type = "l",
ylim = c(0, 100), ylab = "", lwd = 2, col = "red")
plot(x, dnorm(x, mean = 1.6896, sd = 0.0786), type = "l",
ylim = c(0, 20), ylab = "", lwd = 2, col = "red")
plot(x, dnorm(x, mean = 1.6896, sd = 0.0786), type = "l",
ylim = c(0, 6), ylab = "", lwd = 2, col = "red")
# Rejilla de valores para x
x <- seq(1.40, 2, length=1000)
# Rejilla de valores para x
x <- seq(1.40, 2, length=1000) * 0.0786 +1.6896
# Rejilla de valores para x
x <- seq(1.40, 2, length=100) * 0.0786 +1.6896
x
# Rejilla de valores para x
x <- seq(-3, 3, length=100) * 0.0786 +1.6896
x
# Rejilla de valores para x
x <- seq(-3, 3, length=1000) * 0.0786 +1.6896
# Media y desviación estándar
mu <- 1.6896
sigma <- 0.0786
# Rejilla de valores para x
x <- seq(-3, 3, length=1000) * sigma + mu
x
# Función de densidad
f <- dnorm(x, mu, sigma)
plot(x, f, type = "l", lwd = 2, col = "blue", ylab = "", xlab = "Weight")
abline(v = mu) # Línea vertical en la media
# Función de densidad
f <- dnorm(x, mu, sigma)
plot(x, f, type = "l", lwd = 2, col = "blue", ylab = "", xlab = "Weight")
abline(v = mu) # Línea vertical en la media
# Media y desviación típica
mu <- 1000
sigma <- 10
# Grid para una distribución normal no estándar
x <- seq(-3, 3, length = 100) * sigma + mu
# Función de densidad
f <- dnorm(x, mu, sigma)
plot(x, f, type = "l", lwd = 2, col = "blue", ylab = "", xlab = "Weight")
abline(v = mu) # Línea vertical en la media
# Media y desviación típica
mu <- 168.96
sigma <- 7.86
# Grid para una distribución normal no estándar
x <- seq(-3, 3, length = 100) * sigma + mu
# Función de densidad
f <- dnorm(x, mu, sigma)
plot(x, f, type = "l", lwd = 2, col = "blue", ylab = "", xlab = "Weight")
abline(v = mu) # Línea vertical en la media
# Media y desviación estándar
mu <- 168.96
sigma <- 7.86
# Rejilla de valores para x
x <- seq(-3, 3, length=1000) * sigma + mu
# Función de densidad
f <- dnorm(x, mu, sigma)
plot(x, f, type = "l", lwd = 2, col = "blue", ylab = "", xlab = "Weight")
abline(v = mu) # Línea vertical en la media
abline(v1 = mu-1.96*sigma) # Línea vertical en la media
abline(v1 = (mu-1.96*sigma)) # Línea vertical en la media
abline(v = (mu-1.96*sigma)) # Línea vertical en la media
abline(v = (mu+1.96*sigma)) # Línea vertical en la media
mean(x)
sd(x)
?dnorm
# Media y desviación estándar
mu <- 168.96
sigma <- 7.86
# Rejilla de valores para x
x <- seq(-3, 3, length=1000) * sigma + mu
# Función de densidad
f <- dnorm(x, mu, sigma)
plot(x, f, type = "l", lwd = 2, col = "blue", ylab = "", xlab = "Weight")
abline(v = mu) # Línea vertical en la media
abline(v = (mu-1.96*sigma)) # Línea vertical en la media
abline(v = (mu+1.96*sigma)) # Línea vertical en la media
install.packages("ggplot2")
N <- seq(100, 30000, by=10) # Secuencia del 100 al 30,000 con saltos de 10 en 10
N
max(N)
r = 0.05 # Error absoluto de +/-5%
p = 0.5 # Proporción de 50%
q = 1-p
Z = 1.96 # Valor para un nivel de 95% de confianza
n <- ((Z^2)*N*p*q) / (((r^2)*(N-1)) + ((Z^2)*p*q)) #
n
# N <- seq(100, 30000, by=10) # Secuencia del 100 al 30,000 con saltos de 10 en 10
N = 25000
r = 0.03 # Error absoluto de +/-5%
p = 0.5 # Proporción de 50%
q = 1-p
Z = 1.96 # Valor para un nivel de 95% de confianza
n <- ((Z^2)*N*p*q) / (((r^2)*(N-1)) + ((Z^2)*p*q)) #
n
r = 0.025 # Error absoluto de +/-5%
n <- ((Z^2)*N*p*q) / (((r^2)*(N-1)) + ((Z^2)*p*q)) #
n
